# 执行上下文

## 静态作用域

函数的作用域在函数定义的时候就决定了。

## 执行上下文栈

当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。

对于每个执行上下文，都有三个重要属性：

1. 变量对象(Variable object，VO)
2. 作用域链(Scope chain)
3. this

当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

## 变量对象

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

### 全局上下文

全局上下文中的变量对象就是全局对象呐！

### 函数上下文

在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。

### 执行过程

执行上下文的代码会分成两个阶段进行处理：分析和执行

1. 分析
2. 执行

#### 分析

当进入执行上下文时，这时候还没有执行代码，

变量对象会包括：

- 函数的所有形参 (如果是函数上下文)

  - 由名称和对应值组成的一个变量对象的属性被创建
  - 没有实参，属性值设为 undefined
  - 函数声明

- 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
  - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
  - 变量声明

- 由名称和对应值（undefined）组成一个变量对象的属性被创建；
  - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性

这也是为什么JS用var,function会有变量提升

#### 执行

在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值

## 作用域链

函数的作用域在函数定义的时候就决定了。

这是因为函数有一个内部属性 `[[scope]]`，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 `[[scope]]`就是所有父变量对象的层级链，但是注意：`[[scope]]` 并不代表完整的作用域链！

当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端（所以是在分析阶段，执行之前就已经获取）。

这时候执行上下文的作用域链，我们命名为 Scope：

```js
Scope = [AO].concat([[Scope]]);
```

至此，作用域链创建完毕。所以作用域链显然包括自己的变量对象

## this

注意:**this指向的是调用他的事物**

this一般有几种调用场景

```js
var obj = {
    a: 1,
    b(){
        console.log(this);
    },
    c(){
        return () => {
            console.log(this);
        };
    }
}
```

1. 作为对象调用时，指向该对象 obj.b(); // 指向obj

2. 作为函数调用, var b = obj.b; b(); // 指向全局window

3. 作为构造函数调用 var b = new Fun(); // this指向当前实例对象

4. 作为call与apply调用 obj.b.apply(object, []); // this指向当前的object

5. 箭头函数的this obj.c()(); //obj,因为箭头函数本身没this，他的this都是直接拿外面的this所以直接拿c()里的this,在obj.c()()这种情况下即obj

## 闭包

闭包 = 函数 + 函数能够访问的自由变量

```js
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}

var foo = checkscope();
foo();
```

首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况。

1. 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2. 全局执行上下文初始化
3. 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈
4. checkscope 执行上下文初始化，创建变量对象、作用域链、this等
5. checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出
6. 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈
7. f 执行上下文初始化，创建变量对象、作用域链、this等
8. f 函数执行完毕，f 函数上下文从执行上下文栈中弹出

了解到这个过程，我们应该思考一个问题，那就是：

当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？

然而 JavaScript 却是可以的！

当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：

```js
fContext = {
    Scope: [AO, checkscopeContext.AO, globalContext.VO],
}
```

对的，就是因为这个作用域链，`f` 函数依然可以读取到 `checkscopeContext.AO` 的值，说明当 `f` 函数引用了 `checkscopeContext.AO` 中的值的时候，即使 `checkscopeContext` 被销毁了，但是 JavaScript 依然会让 `checkscopeContext.AO` 活在内存中，`f`函数依然可以通过 `f` 函数的作用域链找到它，正是因为JavaScript做到了这一点，从而实现了闭包这个概念。

所以，让我们再看一遍实践角度上闭包的定义：

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量