# 前端性能优化

## 网络方面

### tcp/ip的并发限制

- 浏览器对同一域名下并发的tcp连接是有限制的（2-10个不等）

- 而且在http1.0中往往一个资源下载就需要对应一个tcp/ip请求

#### 优化手段1：合并请求

- 合并请求的主要目的是减少浏览器对服务器发起的请求数，从而减少在发起请求过程中花费的时间，如合并JS、合并CSS以及合并小图片（也就是使用CSS精灵）等方式来减少请求。

#### 优化手段2：域名拆分

- 域名拆分主要是为了增加浏览器下载的并行度，让浏览器能同时发起更多的请求。

由于在同域名的资源请求时，浏览器会默认带上本地的cookie，所以

- 将静态资源分组，分别放到不同的域名下（如static.base.com）

- 而page.base.com（页面所在域名）下请求时，是不会带上static.base.com域名的cookie的，所以就避免了浪费

说到了多域名拆分，这里再提一个问题，那就是在移动端，如果请求的域名数过多，会降低请求速度（因为域名整套解析流程是很耗费时间的，而且移动端一般带宽都比不上pc）

- 此时就需要用到一种优化方案：dns-prefetch（让浏览器空闲时提前解析dns域名，不过也请合理使用，勿滥用）

#### 优化手段3：开启Gzip

- Gzip是一种压缩技术，可以将资源在服务端进行压缩，然后发送给浏览器后再进行解压，这种方式会降低传输大小，提高网页加载性能。

#### 优化手段4：开启KeepAlive

- 开启KeepAlive能够减少浏览器与服务器建立连接的次数，从而节省建立连接时间（http1.1默认开启）

#### 优化手段5：Minify

- Minify指的是将JS和CSS等文本文件进行最小化处理

#### 优化手段6：缓存

- cache-control等等http头部

#### 优化手段7：CDN传输静态资源

- CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

#### 优化手段8：HTTP 2.0

简述下http2.0与http1.1的显著不同点：

- http1.1中，每请求一个资源，都是需要开启一个tcp/ip连接的，所以对应的结果是，每一个资源对应一个tcp/ip请求，由于tcp/ip本身有并发数限制，所以当资源一多，速度就显著慢下来
- http2.0中，一个tcp/ip请求可以请求多个资源，也就是说，只要一次tcp/ip请求，就可以请求若干个资源，分割成更小的帧请求，速度明显提升

所以，如果http2.0全面应用，很多http1.1中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等）

- 多路复用（即一个tcp/ip连接可以请求多个资源）
- 首部压缩（http头部压缩，减少体积）
- 二进制分帧（在应用层跟传送层之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）
- 服务器端推送（服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端）
- 请求优先级（如果流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）

## 程序性能优化

### 优化手段1：减少或合并DOM操作，减少回流

- 减少逐项更改样式，最好一次性更改style，或者将样式定义为class并一次性更新
- 避免循环操作dom，创建一个documentFragment或div，在它上面应用所有DOM操作，最后再把它添加到window.document
- 避免多次读取offset等属性。无法避免则将它们缓存到变量
- 将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
- 动画使用requestAnimationFrame，而不是setTimeOut

### 优化手段2：提升渲染性能

#### CSS资源的处理有几个特点：

- CSS下载时异步，不会阻塞浏览器构建DOM树
- 但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）有例外，media query声明的CSS是不会阻塞渲染的

#### JS脚本资源的处理有几个特点：

- 阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML
- 浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已
- defer与async，普通的脚本是会阻塞浏览器解析的，但是可以加上defer或async属性，这样脚本就变成异步了，可以等到解析完毕后再执行
- 注意，defer和async是有区别的： defer是延迟执行，而async是异步执行。

所以最好把link要写在head里，script要在body底部

### 浏览器的优化（内存方面）

- 这部分前端好像管不到

V8为例

#### 回收机制

JS有垃圾处理器，所以无需手动回收内存，而是由垃圾处理器自动处理。

一般来说，垃圾处理器有自己的回收策略。

譬如对于那些执行完毕的函数，如果没有外部引用（被引用的话会形成闭包），则会回收。（当然一般会把回收动作切割到不同的时间段执行，防止影响性能）

常用的两种垃圾回收规则是：

- 标记清除
- 引用计数

Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除），简单解释如下：

- 遍历所有可访问的对象。
- 回收已不可访问的对象。

##### GC的缺陷

和其他语言一样，javascript的GC策略也无法避免一个问题： GC时，停止响应其他操作

这是为了安全考虑。

而Javascript的GC在100ms甚至以上

对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。

这就是引擎需要优化的点： 避免GC造成的长时间停止响应。

##### GC优化策略

这里介绍常用到的：分代回收（Generation GC），node v8引擎就是采用的分代回收

目的是通过区分“临时”与“持久”对象:

- 多回收“临时对象”区（young generation）
- 少回收“持久对象”区（tenured generation）
- 减少每次需遍历的对象，从而减少每次GC的耗时。

## 资源分配优化

### 优化手段1：分页

### 优化手段2：预加载

### 优化手段3：懒加载